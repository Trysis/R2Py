// [[Rcpp::plugins(cpp11)]]
#include <Rcpp.h>
#include <ctime>
#include <math.h>
using namespace Rcpp;
const double EPS =  1.e-8;
const double MAXITER =  200;


// [[Rcpp::export]]
double distloc(NumericMatrix X, int ind1, int ind2) {
  int i;
  double x,y,sum=0;
  for (i=0;i<3;i++) {
    x=X(ind1-1,i);
    y=X(ind2-1,i);
    sum+=(x-y)*(x-y);
  }
  return sqrt(sum);
}

// (V(v,0),V(v,1)): link number v (query, target) (!:base 1)
//' Constructs vertex table V
//'
//' @param XProp
//' @param YProp
//' @export
// [[Rcpp::export]]
IntegerMatrix vertexc(CharacterVector XProp,  CharacterVector YProp) {
  int i,ip,v=0;
  int N=XProp.size();
  int M=YProp.size();
  IntegerMatrix V(N*M,2);
  for(i=0; i<M; i++)
    for (ip=0; ip<N; ip++)
      if (strcmp(XProp(ip),YProp(i))==0) { 
	V(v,0)=i+1;
	V(v,1)=ip+1;
	v++;
      }
  if (v<=1) {
    fprintf(stderr,"no product graph...\n");
    return V(Range(0,0),_);
  }
  return V(Range(0,v-1),_);
}


// [[Rcpp::export]]
NumericVector mapping_score(NumericMatrix X, IntegerVector XRes, IntegerVector I, IntegerVector CI, NumericMatrix Y, IntegerVector YRes, IntegerVector J, IntegerVector CJ, double thresh) {
  double  score, sc, d1, d2, deltadist;
  int i,j,n;

  n=I.size();
  //printf("mapping_dist_sum %d %d\n", I.size(), CI.size());
  if (thresh<=0.) thresh=15.; //patchsearch_NEIDIST
  NumericVector scores(n);
  for (i=0; i<I.size();i++) {
    score=0.;
    for (j=0; j<CI.size();j++) {
      sc=0.0;
      if (CJ(j)==J(i) || CI(j)==I(i)) {// breaks cliques
        sc=0.;
        //break;
      } else if (CJ(j)==J(i) &&  CI(j)==I(i)) {
	sc=1.0;
      }
      else {
	d1=distloc(Y,CJ(j),J(i));
	d2=distloc(X,CI(j),I(i));
	deltadist=fabs(d1-d2);
	sc=1-deltadist/thresh;
      }
      //if (deltadist>thresh) sc=0.;
      score=score+sc;
    }
    //printf("scores[%d]=%lf\n", i, score);
    scores[i]=score;
  }
  return scores;
}



// [[Rcpp::export]]
NumericVector mapping_score2(NumericMatrix X, IntegerVector XRes, IntegerVector I, IntegerVector CI, NumericMatrix Y, IntegerVector YRes, IntegerVector J, IntegerVector CJ, double thresh) {
  double  score, sc, d1, d2, deltadist;
  int i,j,n;

  n=I.size();
  if (thresh<=0.) thresh=15.; //patchsearch_NEIDIST
  NumericVector scores(n);
  for (i=0; i<I.size();i++) {
    score=0.;
    for (j=0; j<CI.size();j++) {
       sc=0.0;
       if ((CJ(j)==J(i) && CI(j)!=I(i)) || (CI(j)==I(i) && CJ(j)!=J(i))) {
        score=0.;
        break;
       }
       else if (CJ(j)==J(i) &&  CI(j)==I(i)) {// not necessary except sc=0
        sc=1.;
       }
       else {
	 d1=distloc(Y,CJ(j),J(i));
	 d2=distloc(X,CI(j),I(i));
	 deltadist=fabs(d1-d2);
	 sc=1-deltadist/thresh;
      //if (deltadist>thresh) sc=0.;
       }
       score=score+sc;
    }
    //printf("scores[%d]=%lf\n", i, score);
    scores[i]=score;
  }
  return scores;
}

// all nodes in V connected to at least nbnei in C
// [[Rcpp::export]]
IntegerVector getConnectedNeighborsc(IntegerVector C, IntegerMatrix V, NumericMatrix X, NumericMatrix Y, double thresh, int nbnei) {
  int i,j,inC,count=0;
  int nC=C.size();
  IntegerVector K;
  IntegerVector I(nC), J(nC);
  int N=X.nrow();

  for (int i=0; i < nC; i++) {
    I(i)=(C(i)-1)%N+1;
    J(i)=(int)(C(i)-1)/N+1;
  }

  double deltadist, d1, d2;
  for (j=0; j<V.nrow(); j++) {
    count=0;
    inC=0;
    for (i=0; i<nC; i++) {
      if (J(i)!=V(j,0) || I(i)!=V(j,1)) {
	d1=distloc(Y,J(i),V(j,0));
	d2=distloc(X,I(i),V(j,1));
	deltadist=fabs(d1-d2);
	//deltadist=fabs(d1-d2)/std::min(d1,d2);
	if (deltadist<=thresh) count++;
      }
      else inC=1; // j is in C
    }
    if (count>=nbnei && !inC) K.push_back((V(j,0)-1)*N+V(j,1));
  }
  return K;
}



//' Constructs product graph: absolute delta_dist
//'
//' @param X matrix Nx3
//' @param Y matrix Nx3
//' @param V matrix Nvx2
//' @export
// [[Rcpp::export]]
IntegerMatrix buildGraph2c(NumericMatrix X, IntegerVector XRes, NumericMatrix Y, IntegerVector YRes, IntegerMatrix V,  double thresh, double mindist, double maxdist) {
  int i,j, tres, qres, nv, e=0;
  double d,d1,d2;
  std::vector<int> Etmp;
  
  nv=V.nrow();
  for(i=0; i<nv-1; i++) {
    for (j=i+1; j<nv; j++) {
      //printf("%d %d %d %d\n",V(i,0),V(j,0),V(i,1),V(j,1));
      d1=distloc(Y,V(i,0),V(j,0)); // dist between atoms i and j in Y
      d2=distloc(X,V(i,1),V(j,1)); // dist between atoms i and j in X
      d=fabs(d1-d2);
      qres=(YRes(V(i,0)-1)==YRes(V(j,0)-1));
      tres=(XRes(V(i,1)-1)==XRes(V(j,1)-1));
      if (d<=thresh && d1>=mindist && d2>=mindist && d1<=maxdist && d2<=maxdist && !(qres || tres)) {
	      Etmp.push_back(V(i,1));
	      Etmp.push_back(V(j,1));
	      Etmp.push_back(V(i,0));
	      Etmp.push_back(V(j,0));
	      e+=1;
	}
    }
  }
  int n=Etmp.size();
  IntegerMatrix E(e,4);
  for (i=0,j=0; i<n-3; i+=4,j++) {
    E(j,0)=Etmp[i];
    E(j,1)=Etmp[i+1];
    E(j,2)=Etmp[i+2];
    E(j,3)=Etmp[i+3];
  }
  Etmp.clear();
return E;
}

